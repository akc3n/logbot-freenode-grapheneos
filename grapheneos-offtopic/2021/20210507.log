00:07:09 <lackshan[m]> covid-1984 I'm pretty sure some researchers proved that you can record audio via the gyroscope
00:14:43 <covid-1984[m]> Interesting. Sounds difficult to do well though
00:17:01 <louipc> lolwat
01:38:59 <StVM[m]> I really appreciate that there is now a logbot for offtopic room. Living on the other side of the world from most of you, means all those discussion happen when I slept, and almost silent when I woke up.
02:19:40 <koncrete[m]> What would be the best and most secure and anonymous way to Chat on Tails with someone else?
02:20:34 <troypatrick[m]> Tox
02:20:44 <troypatrick[m]> <koncrete[m] "What would be the best and most "> Tox
02:30:36 <faxing[m]> <koncrete[m] "What would be the best and most "> XMPP + OTR if you just want maximum anonymity at the possible cost of message security.  Matrix signed up on Tails used exclusively over tails for good message security on the condition of metadata leakage.  Jami if you don't mind a more centralized service and you know the downsides of P2P.
02:34:39 <akc3n[m]> OTR is old and has issues. Omemo is the replacement faxing
02:39:07 <Baobab> My friends call it omeme.
02:39:13 <Baobab> It
02:39:21 <Baobab> It's really good though.
02:52:28 <akc3n[m]> faxing:  https://wiki.xmpp.org/web/OTR
02:52:28 <akc3n[m]> > OTR is no longer recommended in the XMPP network as it has widely been replaced by OMEMO
02:57:42 <ypm[m]> What do you all think of nix and guix? is it a step in the right direction for linux security or not even close? i assume their packaging system makes it easy to properly sandbox everything
03:02:30 <faxing[m]> Neither are great
03:03:00 <faxing[m]>  * Let's be honest, neither are the gold standard (or really much good at all), but just a bit of habit, you're right lol
03:05:34 <ypm[m]> i dont use either but seems like it solves the flatpak/snap disaster on linux. thought it was interesting although might be a bit off topic here haha
03:15:33 <bastinjasvi11[m]> Hello. Is it possible to change device password which I configured on lockerapp ? Pass whivh on X wrong attempts deletes all. I was testing and I put nonsafe password because I was thinking it is easy to vhange. Do I need to do factory reset or there is the way ?
03:24:54 <Telegram-Bridge> <!Tickmag> After clearing vanadium data, all browsing history remains
04:43:17 <anonhat[m]> <bastinjasvi11[m] "Hello. Is it possible to change "> I just looked up the app on Google Play. Looks like a password manager rather than a custom device locker. I would suggest contacting the developers directly to ask them about it. You should be able to find their contact info on the app page on the Play store.
06:21:55 * bradgarlinghouse  < https://matrix.org/_matrix/media/r0/download/matrix.org/scISnNIEUpouZTPMuPXSEoaR/message.txt >
06:24:14 <whiskey0111[m]> Windows will not be able to access the data in the Linux partition if you encrypt it
06:27:20 <bradgarlinghouse> <whiskey0111[m] "Windows will not be able to acce"> Can I choose to do that when I'm installing Linux? Or will I need third party software to do that?
06:27:26 <EV-9600[m]> If you want to be completely safe you should also use a read-only bootloader
06:27:58 <bradgarlinghouse> <EV-9600[m] "If you want to be completely saf"> What does that mean? üòÖ
06:28:06 <EV-9600[m]> Otherwise the Windows will be able to modify the bootloader to "fake boot" into your Linux and keylog your encryption password
06:28:51 <EV-9600[m]> <bradgarlinghouse "What does that mean? üòÖ"> You would probably use grub as your bootloader, so install grub on a read-only CD, then always boot from that CD
06:29:03 <bradgarlinghouse> <EV-9600[m] "Otherwise the Windows will be ab"> Yeah okay - I see.
06:29:35 <EV-9600[m]> <EV-9600[m] "Otherwise the Windows will be ab"> Depends on how paranoid you are, it might be worth it, not really hard to do
06:30:51 <bradgarlinghouse> On a paranoid scale from 1 to 10, I'm probably 8, haha
06:33:10 <bradgarlinghouse> My laptop doesn't come with a CD reader, but I guess I could go so far as creating a third partition, containing Grub right?
06:45:35 <bradgarlinghouse> If any of you have other and better suggestions to how I could do it, just fire - I'm all ears üòä
07:42:30 <EV-9600[m]> <bradgarlinghouse "My laptop doesn't come with a CD"> That won't really do, because Windows will be able to edit this partition
07:42:49 <EV-9600[m]> You could get a read-only switchable USB drive for pretty cheap
07:45:08 <EV-9600[m]> https://www.kanguru.com/mobile/m.kanguru-usb-drives-comparison-chart.html
07:45:11 <EV-9600[m]> The SS3 one, you can get the one with smallest size
07:46:50 <EV-9600[m]> <bradgarlinghouse "On a paranoid scale from 1 to 10"> You might also want to consider running only Linux and run Windows in a VM
07:47:35 <EV-9600[m]> Otherwise Windows will have access to some metadata about your Linux which you might not want
07:49:12 <EV-9600[m]> If you choose to go the grub way, read about grub-mkrescue, this is the command to create a bootable iso that you can then right on your write protected USB
08:05:12 <EV-9600[m]> * If you choose to go the grub way, read about grub-mkrescue, this is the command to create a bootable iso that you can then write on your write protected USB
08:07:18 <bradgarlinghouse> <EV-9600[m] "You might also want to consider "> Amazing advice. Is a Windows VM capable of running all Windows dependent programs and games?
08:07:49 <bradgarlinghouse> <EV-9600[m] "If you choose to go the grub way"> And thank you for this advice as well.
08:08:52 <EV-9600[m]> <bradgarlinghouse "Amazing advice. Is a Windows VM "> Probably yes, Look at VFIO for games
08:09:51 <EV-9600[m]> Technically stuff that is going to use real hardware won't work and there are probably bugs that will cause some programs not to work, but I believe you aren't going to encounter them as they are very rare
08:12:10 <EV-9600[m]> Performance is going to be very poor but VFIO can fix this
08:18:42 <whiskey0111[m]> if your Laptop has to graphics cards you can pass through one of them to the VM
08:31:35 <EV-9600[m]> I am looking at the source code of a certain app and I see this line:
08:31:35 <EV-9600[m]> `pMgr.getNameForUid(app.getUid())`
08:31:35 <EV-9600[m]> Do you know If this will always return the same value for every app?
08:32:07 <EV-9600[m]> And how can I determine what this usernames is?
08:32:33 * EV-9600[m]  < https://matrix.org/_matrix/media/r0/download/matrix.org/FVHXfiSoBvvUAECwrJhavtZJ/message.txt >
08:32:48 <EV-9600[m]> * I know it can technically do anything, so let's assume it really does return the username of the app
08:35:25 <EV-9600[m]> And if not, then what identifier can I use, and how, to get the username of a certain app
11:45:13 <covid-1984[m]> <ypm[m] "What do you all think of nix and"> I think they add more complexity than people expect. The evidence being how hard it is for people who are already Linux experts to figure out how to build any pkg they want (you can see hundreds of comments on various websites for such experiences; talking NixOS specifically).
11:50:32 <lackshan[m]> Is there a guide somewhere that explains how/why I should use multiple user profiles on GOS?
11:55:52 <theogrelord[m]> <lackshan[m] "Is there a guide somewhere that "> This should help: https://grapheneos.org/faq#encryption
12:07:16 <lackshan[m]> theogrelord Thank you!
13:04:33 <Baba[m]> *Quick question* : if malicious APP of high potential get installed on my phone and compromised.
13:04:33 <Baba[m]> Would i get back my phones to normal by unstalling the app and formating the mobile or by reinstalling the OS. Or my phone just go out of my reach and should throw in trash bin.
13:10:31 <EV-9600[m]> I know CalyxOS has done harm to this project, do you have any detailed explanation about what happened?
13:11:45 <EV-9600[m]> > <@mazyani:matrix.org> *Quick question* : if malicious APP of high potential get installed on my phone and compromised.
13:11:45 <EV-9600[m]> > Would i get back my phones to normal by unstalling the app and formating the mobile or by reinstalling the OS. Or my phone just go out of my reach and should throw in trash bin.
13:11:45 <EV-9600[m]> If you reflash your os you would probably be fine, but it depends on the reach of the app
13:12:39 <Baba[m]> <EV-9600[m] "> <@mazyani:matrix.org> *Quick q"> What do you mean by reach of the app?
13:13:02 <EV-9600[m]> Like what kind of permissions it managed to get
13:13:30 <EV-9600[m]> If it somehow compromised the Titan M (should be impossible) you are out of luck
13:14:18 <EV-9600[m]> If it has enough permissions to "fake restart" and never run out of battery (not really that hard) you are also out of luck
13:15:31 <EV-9600[m]> (And somehow make it impossible to shutdown your phone by long pressing the power off button, which should be impossible)
13:16:46 <Baba[m]> üò≥üò≥üò≥üò≥
13:17:43 <EV-9600[m]> If you want to be mostly fine, just make sure to turn off the device by long pressing the power off button and not through the ui, before flashing
13:18:49 <EV-9600[m]> Nothing is ever perfect, but an actor who can bypass reflashing of the OS after a long press has *lots* of resources
13:19:46 <EV-9600[m]> If you already used the Auditor app with someone before, you might be better just verifying your phone
13:20:48 <Baba[m]> Thankx @EV-9600:matrix.org
13:22:17 <EV-9600[m]> <EV-9600[m] "If you already used the Auditor "> The pros of this, is you'll make sure your system isn't compromised at the OS level, the con is, the app might still run in the background if it somehow bypassed graphene's protections (should be impossible, and without further vulunarability, shouldn't be able to do much, as it should run in a sandbox, but again it might somehow spread more)
13:23:09 <DHFuchsiaOSwhen> If you don't grant it some powerful permissions, it cannot do much
13:23:15 <DHFuchsiaOSwhen> without an OS exploit
13:27:34 <koncrete[m]> This is a off topic question but should i start gambling on roobet
13:28:14 <koncrete[m]> Need advice
13:29:10 <covid-1984[m]> The house always wins
13:55:53 <nscnt[m]> @EV-9600:matrix.org: Please minimize causing fears if the things you mention are quite imaginary and not really realistic
13:56:26 <Telegram-Bridge> <L‚Äã73689> When using the auditor app, what does a green and orange background mean
13:59:42 <nscnt[m]>  * @EV-9600:matrix.org: Please minimize causing fears if the things you mention are quite imaginary and not really realistic anyway
14:04:17 <nscnt[m]> @L73689 Emphasis with color what is written there anyway. Orange for an initial verification and pairing and green for a successful paired verification and identity confirmation.
14:04:55 <Telegram-Bridge> <L‚Äã73689> When using the auditor app, what does a green and orange background mean
14:06:07 <Telegram-Bridge> <L‚Äã73689> So whats the difference?
14:06:07 <Telegram-Bridge> <L‚Äã73689> Some user accounts show as green and some as orange when using the auditor app
14:10:45 <nscnt[m]> I just gave you the explanation
14:19:02 <Telegram-Bridge> <L‚Äã73689> So should I be worried about an orange colour vs green?
14:24:27 <koncrete[m]> Can anyone recommend me a Privacy Friendly Cryptocurrency wallet?
14:24:55 <koncrete[m]> That doesn't require an ID or something like that
14:25:02 <Telegram-Bridge> <L‚Äã73689> When using the auditor app, what does a green and orange background mean
14:25:02 <koncrete[m]> * That doesn't require an ID
14:25:21 <Telegram-Bridge> <L‚Äã73689> So should I be worried about an orange colour vs green?
14:25:35 <koncrete[m]> * That doesn't require an ID, and you can buy coins with a credit card
14:27:33 <falldamagedpixel> Any way to fix a Pixel that went black screen and refused to boot after falling to the floor?
14:27:52 <falldamagedpixel> Like any known reasons like anti-tampering or something?
14:30:31 <Telegram-Bridge> <L‚Äã73689> So should I be worried about an orange colour vs green?
14:32:04 <falldamagedpixel> Yeah?
14:32:26 <falldamagedpixel> Wait, isn't that just the initial attestaion (weak pairing)?
14:35:31 <Telegram-Bridge> <L‚Äã73689> I really don't know what the weak pairing or initial pairing is, I've tried to look online also but no explanation
14:51:44 <nscnt[m]> @L‚Äã73689 It's the Trust On First Use (TOFU) model. No, you don't need to be worried if it's orange. The initial pairing is the weakest. https://attestation.app/about
14:53:07 <nscnt[m]> Different users have a different identity. It's orange if you haven't had an initial pairing (with the current user)
14:54:32 <nscnt[m]> It will be green next time if it can be successfully verified again
14:58:00 <Telegram-Bridge> <L‚Äã73689> Thank you , I've done it again and its green as you said cheers, am I right in thinking this is a good way to check to see if the phone has been tampered with via a dodgy app download?
14:59:42 <hypokeimenon[m]> https://www.eff.org/deeplinks/2021/05/foriegn-intelligence-surveillance-court-rubber-stamps-mass-surveillance-under
14:59:49 <hypokeimenon[m]> Leaders of the free world everybody
15:00:54 <Telegram-Bridge> <L‚Äã73689> Ohhhh so after reading that website , do you pair your graphene with another phone using auditor and then in the future , you use the same phone to audit your graphene to see if anything has changed?
15:05:12 <EV-9600[m]> I know CalyxOS has done harm to this project, do you have any detailed explanation about what happened?
15:14:38 <nscnt[m]> @EV-9600:matrix.org: Read some logs
15:15:21 <EV-9600[m]> What logs?
15:16:26 <nscnt[m]> https://freenode.logbot.info/grapheneos
15:16:30 <nscnt[m]> https://freenode.logbot.info/grapheneos-offtopic
15:19:21 <nscnt[m]> You'll find several statements at different times explaining what's going on
16:08:38 <Telegram-Bridge> Le Chevalier (@P‚ÄãAN0PT1KON) has joined the Telegram Group!
16:25:27 <Telegram-Bridge> <!Hulk> You shouldn't be using adb
16:25:40 <Telegram-Bridge> <!Hulk> Just let the browser handle everything
16:26:11 <taabcndefodvgkry> issue is adb is local to a folder right now
16:27:11 <Telegram-Bridge> <!Hulk> What do you mean by that?
16:27:31 <Telegram-Bridge> <!Hulk> As I said, delete everything that can interfere
16:27:43 <taabcndefodvgkry> running adb in terminal  "zsh: permission denied: adb"
16:28:16 <Telegram-Bridge> <!Hulk> Are you trying to do everything thru the terminal?
16:32:13 <Telegram-Bridge> <!Hulk> bradgarlinghaouse: you should really review your threat model
16:33:38 <bradgarlinghouse> <Telegram-Bridge "<!Hulk> bradgarlinghaouse: you s"> What the heck does this mean? üòÜ
16:34:47 <Telegram-Bridge> <!Hulk> Suggested reading: https://ssd.eff.org/en/module/your-security-plan
16:35:52 <Telegram-Bridge> <!Hulk> Remember that by using Google Pixel (even with GrapheneOS installed) you must trust Google
16:36:38 <Telegram-Bridge> <!Hulk> Unless you build your hardware yourself, you cannot distrust your manufacturer
16:37:31 <Telegram-Bridge> <!Hulk> (I hope my English is not terribly bad, and my statements above were worded well)
16:45:26 <taabcndefodvgkry> <Telegram-Bridge "<!Hulk> Are you trying to do eve"> no
16:45:37 <taabcndefodvgkry> I guess it's not an issue then
16:45:50 <taabcndefodvgkry> but https://flash.android.com/devices wont recognize my phone
16:46:59 <Telegram-Bridge> <!Hulk> Is your Chrome browser is all-default settings?
16:47:44 <taabcndefodvgkry> <Telegram-Bridge "<!Hulk> Is your Chrome browser i"> yes, just downloaded it
16:48:50 <Telegram-Bridge> <!Hulk> Does your phone show a notification "USB debugging enabled"?
16:50:23 <doittoit[m]> Help lease ... üòÅ   After flashing coral on pixel 4xl, I clicked "remove non stock key", it confirmed, but booted up with GOS still
16:50:54 <taabcndefodvgkry> <Telegram-Bridge "<!Hulk> Does your phone show a n"> I turned on usb debugging, not sure what you mean
16:51:40 <Telegram-Bridge> <!Hulk> doittoit[m]: read this https://developers.google.com/android/images
16:52:39 <Telegram-Bridge> <!Hulk> taabcndefodvgkry: there must be a notification that confirms that your phone has allowed your computer to do adb
16:53:09 <Telegram-Bridge> <!Hulk> That is, when you connect it to your Mac, it would say "USB debugging enabled" in the notifications
16:54:01 <taabcndefodvgkry> <Telegram-Bridge "<!Hulk> taabcndefodvgkryhz: ther"> there's no pop up when I connect to mac
16:54:36 <Telegram-Bridge> <!Hulk> welp, that's the problem, and the reason why your computer didn't recognized it
16:55:07 <Telegram-Bridge> <!Hulk> Are you sure that USB debugging is still enabled in the developer options?
17:20:44 <nscnt[m]> doittoit: You have to flash the stock OS and then remove the non-stock key before locking the bootloader again. Removing the non-stock key alone is not enough.
17:33:53 * doittoit[m]  < https://matrix.org/_matrix/media/r0/download/matrix.org/eFQsUWdGadPEEbLgumwHthwu/message.txt >
17:36:56 <Telegram-Bridge> <!Hulk> Do not use the OTA
17:37:20 <Telegram-Bridge> <!Hulk> There's a "flash public release" at the bottom of the page
17:37:24 <Telegram-Bridge> <!Hulk> Use that
17:38:47 <doittoit[m]> Under ota images or factory images?
17:39:47 <Telegram-Bridge> <!Hulk> Wrong
17:39:50 <doittoit[m]> Did wordndearch for public release at the link you gave and cant find it.
17:40:02 <doittoit[m]> * Did word search for public release at the link you gave and cant find it.
17:40:10 <Telegram-Bridge> <!Hulk> https://developers.google.com/android/images
17:41:09 <Telegram-Bridge> <!Hulk> Use Android Flash Tool
17:41:35 <Telegram-Bridge> <!Hulk> "flash back to public"
17:45:36 <nscnt[m]> https://flash.android.com/back-to-public
17:54:01 <Telegram-Bridge> Dylly (@D‚Äãylly) has joined the Telegram Group!
17:55:51 <taabcndefodvgkry> <Telegram-Bridge "<!Hulk> welp, that's the problem"> Why would there be no no pop up?
17:57:05 <Telegram-Bridge> <!Hulk> I don't know, but it should be there
17:57:20 <taabcndefodvgkry> <Telegram-Bridge "<!Hulk> I don't know, but it sho"> Do i need to unlock the bootloader?
17:59:28 <Telegram-Bridge> <!Hulk> No, it should be fine automatically by the web-installer
17:59:42 <Telegram-Bridge> <!Hulk> Should be done automatically*
18:00:03 <Telegram-Bridge> <!Hulk> USB debugging is your problem currently
18:01:00 <Telegram-Bridge> <!Hulk> Developer options should be enabled, and both OEM unlocking and USB debugging should be enabled
18:01:10 <taabcndefodvgkry> <Telegram-Bridge "<!Hulk> Developer options should"> I have done that
18:01:14 <Telegram-Bridge> <!Hulk> Do not disable developer options
18:01:36 <taabcndefodvgkry> When I went into bootloader mode it said my phone is locked, is that a problem
18:01:51 <Telegram-Bridge> <!Hulk> Ok look, let me explain
18:02:29 <Telegram-Bridge> <!Hulk> The GrapheneOS web-installer and Google's web-installer are very similar to each other, but they are not the same
18:03:27 <Telegram-Bridge> <!Hulk> Also
18:03:27 <Telegram-Bridge> <!Hulk> There's a separate web installer for AOSP and a separate one for stock
18:03:28 <Telegram-Bridge> <!Hulk> The experience of using Google's web-installer for AOSP/stock is quite similar to GrapheneOS's web-installer
18:03:28 <Telegram-Bridge> <!Hulk> "Android Flash Tool" - is the name of Google's official web-installer
18:03:29 <Telegram-Bridge> <!Hulk> Stock uses adb to reduce the amount of steps required by user interaction
18:03:32 <Telegram-Bridge> <!Hulk> Afaik, adb in this case is used only to boot the phone to the bootloader interface with zero user interaction
18:03:34 <Telegram-Bridge> <!Hulk> While GrapheneOS makes the user to do it manually
18:06:30 <taabcndefodvgkry> Either way, my phone is not connecting to the computer, but why? I have enabled usb debugging & oem unlocking
18:07:02 <Telegram-Bridge> <!Hulk> Are you sure that your cable is not broken?
18:08:16 <taabcndefodvgkry> <Telegram-Bridge "<!Hulk> Are you sure that your c"> I have tried three cables
18:11:45 <Telegram-Bridge> !Hulk shared a photo on Telegram with caption: 'the notification should look like this:'
18:12:07 <Telegram-Bridge> <!Hulk> (i hope you can see the image that i attached on the other side of the bridge)
18:16:21 <Telegram-Bridge> <!Hulk> "USB debugging connected" it should say in the notifications
18:19:15 <doittoit[m]> Telegram-Bridge: nscnt thanks guys for all your help. Got-herrr-done
18:19:52 <nscnt[m]> doittoit: You've got the non-stock key removed as well without issues?
18:20:38 <doittoit[m]> New topic ... why is it taking my 4a 5G 3 hours to download updates etc to become current? Thats crazy. Is there a faster way to get to the latest update so I can put on GOS?
18:20:53 <doittoit[m]> nscnt: yes thank you!
18:20:57 <nscnt[m]> doittoit: Good thing!
18:21:44 <Telegram-Bridge> <!Hulk> No problemüëç
18:22:14 <nscnt[m]> doittoit: What do you mean by downloading 3 hours? Is it actually saying "Downloading update..." for 3 hours or what do you mean?
18:24:29 <taabcndefodvgkry> <Telegram-Bridge "<!Hulk> "USB debugging connected"> I tried with another phone and that came up
18:24:47 <taabcndefodvgkry> But that phone was not mine
18:25:18 <taabcndefodvgkry> Fuck
18:25:22 <taabcndefodvgkry> What happened to my phone
18:25:54 <taabcndefodvgkry> The cable and computer work, it's just the phone that's the issue
18:26:37 <doittoit[m]> Yes ... security and android updates took over 3 hours to complete with new constant supervision nearby ... a physical restart was required 3 times and more and more updates kept being required.
18:27:31 <doittoit[m]> Over wifi at 80mb download
18:29:35 <nscnt[m]> doittoit: Are talking about the stock OS?
18:30:26 <nscnt[m]> doittoit: Ahhh... No, it's all incremental. It really can take a while
18:31:22 <doittoit[m]> Yes stock ... ugh.
18:32:31 <doittoit[m]> Like in "Sandlot" ... "FOR-E-VER"
18:33:42 <Telegram-Bridge> <!Hulk> taabcndefodvgkry: yeah, we identified the issue, but I don't know how to help you here
18:33:59 <Telegram-Bridge> <!Hulk> Worst case scenario, you can try CLI installation
18:34:32 <Telegram-Bridge> <!Hulk> But you should ultra-careful with that, in order to not irreversibly brick your phone
18:34:44 <Telegram-Bridge> <!Hulk> you should be*
18:36:59 <taabcndefodvgkry> <Telegram-Bridge "<!Hulk> But you should ultra-car"> How would that happen?
18:37:07 <taabcndefodvgkry> I did CLI last time i think
18:37:30 <taabcndefodvgkry> To flash Graphene
18:38:17 <Telegram-Bridge> <!Hulk> Like if you accidentally flash a wrong image
18:38:43 <Telegram-Bridge> <!Hulk> For example image for the Pixel 4a on a Pixel 4a5G
18:38:54 <Telegram-Bridge> <!Hulk> That would irreversibly brick the phone
18:39:45 <taabcndefodvgkry> I see
18:40:00 <taabcndefodvgkry> What should I do to figure this out?
18:40:09 <taabcndefodvgkry> Otherwise I need to buy a new phone
18:40:17 <taabcndefodvgkry> Super frustrating
18:40:54 <Telegram-Bridge> <!Hulk> Welp, be sure that you know the full name of your phone
18:41:07 <Telegram-Bridge> <!Hulk> Read this carefully and entirely https://developers.google.com/android/images
18:41:28 <Telegram-Bridge> <!Hulk> And you shall be good
18:42:55 <taabcndefodvgkry> I tried that. My phone simply does not enabled the computer to do anything over usb
18:43:39 <Telegram-Bridge> <!Hulk> Oh, I forgot
18:43:54 <nscnt[m]> taabcndefodvgkryhz: Do you use a browser that supports WebUSB?
18:44:06 <Telegram-Bridge> <!Hulk> I forgot that the phone is not being recognized properly or something
18:44:19 <Telegram-Bridge> <!Hulk> Chrome is what they are using
18:44:28 <nscnt[m]> okay then
18:44:34 <nscnt[m]> ¬Ø\_(„ÉÑ)_/¬Ø
18:45:07 <Telegram-Bridge> <!Hulk> nscnt[m]: we're having troubles with USB debugging, which is needed to revert from GrapheneOS back to Stock
18:46:08 <nscnt[m]> Only if you use the Google's WebUSB-based installer
18:46:48 <nscnt[m]> CLI would be the alternative without the need of adb
18:47:31 <Telegram-Bridge> <!Hulk> Could you help taabcndefodvgkry with going thru CLI back-to-stock process?
18:47:47 <Telegram-Bridge> <!Hulk> I'm not experienced enough at this point
18:48:12 <nscnt[m]> No, I just spend 3 hours on supporting one person. I need a break. It's just following https://grapheneos.org/install/cli
18:48:30 <nscnt[m]> Instead of downloading and flashing a GrapheneOS release, it'll be the stock release
18:49:27 <nscnt[m]> and removing the non-stock key before locking the bootloader
18:50:29 <Telegram-Bridge> <!Hulk> have a good break)
18:50:55 <Telegram-Bridge> <!Hulk> taabcndefodvgkry: let's try this out, shall we?
18:56:33 <nscnt[m]> I don't think it's a USB debugging issue, though
19:02:15 <nscnt[m]> Even if it would work with the CLI, I don't think a non-functioning USB debugging is the cause of their problem
19:03:20 <nscnt[m]> "non-functioning"
20:24:14 <Telegram-Bridge> Lex (@h‚Äãonorablepee) has joined the Telegram Group!
20:42:13 <lackshan[m]> helloworldkk87 What's your solution for a secure desktop? The lack of proper secure boot on mine is concerning
21:00:50 <Telegram-Bridge> <!Hulk> (i know you didn't ask me, but) macOS or Windows 10 are pretty good
21:01:38 <helloworldkk87[m> I dont know why did you ask from me but yeah I agree with hulk tjat macOS and Windows10. Also Qubes is solid
21:02:32 <helloworldkk87[m> * I dont know why did you ask from me but yeah I agree with hulk that macOS and Windows10. Also Qubes is solid
21:04:10 * flawedworld[m]  < https://matrix.org/_matrix/media/r0/download/matrix.org/kVdlqYsmxrZMxzxgPiEKRJtU/message.txt >
21:07:42 <lackshan[m]> Ah right. Is it easy to neuter the data collection on macOS or Windows?
21:08:55 <flawedworld[m]> <lackshan[m] "Ah right. Is it easy to neuter t"> 'data collection' is pretty broad. You can just turn off whatever you dont want.
21:10:21 <flawedworld[m]> Things like Defender Smartscreen and Gatekeeper for example are security features of the OS and it would be unwise to turn it off just because it makes an outbound connection
21:11:45 <flawedworld[m]> Windows 10 has a pretty comprehensive set of group policies which will let you change what connections the OS makes but a lot are harmless and there's a great deal of FUD really when it comes to what 'Telemetry' really means.
21:12:15 <flawedworld[m]> To be honest I would call all of them harmless
21:14:07 <Core6255> I'm abit confused tho, wasn't Linux meant to be the most secure historically speaking? how did this happen?
21:14:57 <Telegram-Bridge> <!Hulk> suggested reading: https://madaidans-insecurities.github.io/
21:15:09 <EV-9600[m]> You should look this up online
21:15:41 <flawedworld[m]> <Core6255 "I'm abit confused tho, wasn't Li"> It never was really if you ask me.
21:15:54 <EV-9600[m]> There are lots of talks in security conferences covering this topic
21:33:27 <Railgun_Lover[m]> <Core6255 "I'm abit confused tho, wasn't Li"> Windows has come a long way
21:33:31 <Railgun_Lover[m]> So has macOS
21:33:53 <Railgun_Lover[m]> Linux currently has not implemented basic security practices from the 70s
21:36:45 <helloworldkk87[m> It can be hardened to be pretty secure
21:39:25 <Railgun_Lover[m]> helloworldkk87: yes but that doesn't fix it
21:40:00 <Railgun_Lover[m]> It's just prevented from contributing to vulnerability and exploits
21:46:51 <helloworldkk87[m> Right
21:58:00 <Telegram-Bridge> <!Hulk> I don't really how to measure/compare security of different operating systems, but I have heard that Qubes + Whonix is a strong combo
21:59:16 <Core6255> why is memory safety important?
21:59:47 <Core6255> memory safe languages* even
22:05:15 <strcat[m]> because the vast majority of code execution vulnerabilities are from memory corruption bugs
22:05:52 <strcat[m]> Linux is definitely not at all secure...
22:06:05 <strcat[m]> it was an anti-security project from the beginning
22:06:21 <strcat[m]> monolithic kernel long past when it was regarded as a good idea due to stability/security being important
22:06:36 <strcat[m]> it's explicitly designed around seriously compromising stability/security to cut corners for more performance
22:06:38 <strcat[m]> that's Linux kernel since day one
22:06:51 <strcat[m]> and the traditional userspace has had even more terrible security from the beginning
22:06:51 <Railgun_Lover[m]> <strcat[m] "it's explicitly designed around "> Which to be fair is a valid use case
22:07:02 <Railgun_Lover[m]> Just not a good idea for most people
22:09:18 <Railgun_Lover[m]> <Core6255 "memory safe languages* even"> The compiler/interpreter of a memory safe  language will throw an error if a memory corruption bug is detected
22:10:11 <Railgun_Lover[m]> An unsafe language like C will continue compiling, when executed will corrupt memory and cause a vulnerability
22:11:26 <strcat[m]> Linux kernel combines monolithic kernel (all code entirely trusted, a bug in some minor / obscure functionality results in an attacker compromising the kernel completely) with being entirely written in a very unsafe memory/type unsafe language unable to build safe abstractions/APIs along with a culture that has typically not been interested in testing, etc. and focus on features + performance through complex
22:11:26 <strcat[m]> approaches
22:12:08 <strcat[m]> result is not something that's stable or secure, and if you actually follow along mainline you'll get to experience tons and tons of regressions / serious issues (many you won't notice, some that you will)
22:12:14 <strcat[m]> they write the bugs faster than they fix them
22:12:24 <ypm[m]> <strcat[m] "Linux kernel combines monolithic"> just curious, what do you think of *BSDs?
22:12:46 <strcat[m]> a lot of that still applies (C, monolithic kernel, etc.)
22:12:53 <Railgun_Lover[m]> <strcat[m] "Linux kernel combines monolithic"> Ouch
22:12:55 <strcat[m]> FreeBSD is pretty much the same kind of culture
22:12:59 <strcat[m]> and same approach
22:13:16 <strcat[m]> OpenBSD is a comparable approach but different culture, still has the same problems with the approach
22:13:22 <strcat[m]>  * OpenBSD is a comparable approach but different culture and priorities, still has the same problems with the approach
22:13:32 <Railgun_Lover[m]> <strcat[m] "they write the bugs faster than "> Probably only focus on speed and not crashing
22:13:41 <Railgun_Lover[m]> Everything else be damned
22:13:45 <strcat[m]> I'd say FreeBSD is less secure than Linux they just don't have the resources to write as many bugs
22:14:07 <strcat[m]> give them more resources and they'd catch up on complexity / bugs
22:14:15 <Railgun_Lover[m]> <strcat[m] "I'd say FreeBSD is less secure t"> Hey then it's more secure!
22:14:18 <Railgun_Lover[m]> Jk
22:14:24 <strcat[m]> no it's not cause it's not all about # of bugs
22:14:30 <Railgun_Lover[m]> <strcat[m] "no it's not cause it's not all a"> I know
22:14:40 <Railgun_Lover[m]> Was intended as a joke, poking fun at cve counting
22:15:03 <strcat[m]> CVEs correspond to bugs that were found by security-focused people and they spent time getting one assigned
22:15:10 <strcat[m]> doesn't correspond to # of security bugs very well
22:15:26 <Railgun_Lover[m]> Projects who focus on security will have more CVEs
22:15:58 <Railgun_Lover[m]> It's a shame Linux is so insecure
22:16:21 <ypm[m]> Whats a proper measure of code "correctness" then? or is it just based on starting off with a mem safe lang
22:16:45 <Railgun_Lover[m]> Then some communities come out and say "open source rules backdoor proprieturdy software"
22:16:56 <Railgun_Lover[m]> <ypm[m] "Whats a proper measure of code ""> Memory safe languages is one
22:17:10 <Railgun_Lover[m]> But idk much else, ask the expert
22:17:40 <ypm[m]> Also hears something about formally proving your code has no bugs but i doubt that's feasible or worth it at all for any meanignfully large project, no?
22:17:46 <strcat[m]> Linux choosing to use a monolithic kernel with everything in the same address space with no boundaries between it makes it vastly more complex
22:17:47 <ypm[m]> * Also heard something about formally proving your code has no bugs but i doubt that's feasible or worth it at all for any meanignfully large project, no?
22:18:05 <strcat[m]> ypm: you would have to design things as tiny little components isolated from each other if you wanted to prove things correct
22:18:45 <ypm[m]> Interesting. You think it's anywhere near possible at the scale of a functional OS?
22:18:54 <strcat[m]> and proving it correct means proving it properly implements a specification
22:18:55 <Railgun_Lover[m]> strcat if fuchsia becomes as stable (meaning few crashes) as Linux, fairly fast, will you switch to it?
22:19:02 <strcat[m]> ypm: you can certainly prove the core kernel is correct
22:19:04 <jj1013[m]> <strcat[m] "Linux choosing to use a monolith"> > everything in the same address space with no boundaries between it
22:19:09 <strcat[m]> just keep in mind that assumes the specification is correct
22:19:21 <strcat[m]> and the hardware is correct and does what the specification thinks it does
22:19:24 <Railgun_Lover[m]> <Railgun_Lover[m] "strcat if fuchsia becomes as sta"> (fairly fast meaning performance, not development)
22:19:50 <strcat[m]> jj1013.: well it does actually mean it uses more memory than it should but not really for the reason you probably think
22:20:04 <strcat[m]> kernel code and data is stuck in memory
22:20:14 <strcat[m]> userspace process code is paged from storage as needed and paged out when idle / useful for other things
22:20:31 <strcat[m]> if the kernel has 20M of code, that's entirely stuck in memory
22:20:44 <strcat[m]> kernel modules are just dynamically loaded libraries not separate components
22:20:50 <Railgun_Lover[m]> Probably because reducing RAM usage is pointless unless you've run out
22:20:51 <strcat[m]> there's no separation between kernel modules and the core kernel
22:21:00 <strcat[m]> same address space, no boundaries, no real rules about what they can do
22:21:10 <strcat[m]> and works the same way once you load them (stuck in memory)
22:21:25 <strcat[m]> if a kernel module makes a mistake like a use-after-free that corrupts memory in the kernel as a whole across all processes
22:21:28 <strcat[m]> it's 1 address space
22:21:54 <Railgun_Lover[m]> Ouch...making a non monolithic kernel would make it so much better
22:21:54 <strcat[m]> so, say your network card driver is for some obscure thing and is hardly maintained (this is the case for the vast majority of drivers)
22:21:56 <strcat[m]> it has some serious bug
22:22:04 <strcat[m]> well, that compromises security of the kernel as a whole
22:22:22 <strcat[m]> and it's C so you make one tiny little mistake or typo and that's a remote code execution bug
22:22:27 <strcat[m]> and those bugs are everywhere
22:22:37 <strcat[m]> a lot are not little mistakes but rather the result of complexity not managed by the tools
22:23:16 <strcat[m]> every time you do any kind of arithmetic in C you need to think, can this overflow? can that result in a buffer overflow, use-after-free, etc. from the integer overflow?
22:23:26 <strcat[m]> that is not how C programmers actually write C though, it wouldn't work at scale
22:23:35 <strcat[m]> and you also can't really answer those kinds of questions in such a complex project
22:23:36 <Railgun_Lover[m]> strcat: does that mean, a non monolithic kernel makes memory safety bugs only affect the userspace instead of the kernel?
22:23:38 <strcat[m]> they just take the YOLO approach
22:23:52 <strcat[m]> I am impersonating Railgun_Lover: a non-monolithic kernel is divided into isolated processes
22:24:03 <strcat[m]> so, for example, say you have a network driver and it has an RCE bug
22:24:14 <strcat[m]> network card is isolated via IOMMU, driver is an isolated component
22:24:19 <Railgun_Lover[m]> <Railgun_Lover[m] "strcat: does that mean, a non mo"> Wait I'm a dumdum
22:24:22 <strcat[m]> so, big deal, they can see encrypted traffic going through the network driver
22:24:27 <strcat[m]> it's still isolated
22:24:27 <Railgun_Lover[m]> Not called a iserspace, I mean the driver
22:24:36 <Railgun_Lover[m]> <Railgun_Lover[m] "Not called a iserspace, I mean t"> My bad
22:24:47 <strcat[m]> same thing for an SSD driver, they can see encrypted disk data going through it, ideally there's authenticated encryption so they can't tamper with it
22:25:08 <strcat[m]> you plug in a flash drive to a Linux-based computer
22:25:22 <strcat[m]> you're trusting the USB driver, block driver, filesystem driver, etc. to be free of exploitable bugs
22:25:34 <strcat[m]> the USB flash drive could have a maliciously crafted filesystem exploiting the ext4 driver, etc.
22:25:42 <strcat[m]> that's all ENTIRELY trusted code
22:25:45 <strcat[m]> like all Linux kernel code
22:25:59 <strcat[m]> any little tiny bug in any of it is easily a code execution vulnerability
22:26:12 <strcat[m]> and, inevitably, you make something this large/complex with such complex approaches and so many features
22:26:14 <strcat[m]> and you write that in C
22:26:19 <strcat[m]> well, you've got tons and tons of these vulnerabilities
22:26:23 <strcat[m]> and they fully compromise the whole kernel
22:26:27 <Railgun_Lover[m]> sekurety
22:26:39 <strcat[m]> Linux kernel approach is equivalent to having the entirely of userspace in the init process running as root
22:26:56 <strcat[m]> imagine if the entirety of the base OS was inside the init process
22:26:56 <Railgun_Lover[m]> this is physically painful to hear
22:27:03 <strcat[m]> that is literally how the Linux kernel is designed
22:27:10 <strcat[m]> half of your OS is designed this way (the kernel)
22:27:41 <strcat[m]> most of the serious security bugs are kernel bugs these days (mostly in drivers)
22:28:27 <strcat[m]> Android at least implements the bulk of driver complexity in userspace and has a lot of kernel attack surface reduction (disabled features, only including what's used, lots of things not exposed to untrusted apps or remotely as usual, etc.)
22:28:34 <strcat[m]> but it's still a very serious problem
22:29:08 <Railgun_Lover[m]> that's...not good
22:29:27 <strcat[m]> people saying Linux is secure are just bullshitting, it's basically just a meme based around Windows being much more widely used on the desktop and traditional desktop OSes lack any real application security model, etc. so malware is a big problem without needing any exploits to break out of app sandboxes
22:29:48 <strcat[m]> if you don't have a security model for applications, etc. then an application being exploited compromises everything anyways
22:30:14 <strcat[m]> once you have an OS with an actual security model / boundaries and tons of effort put into that then you start being able to appreciate the ridiculous insecurity of the Linux kernel
22:30:26 <strcat[m]> for example nearly all Chromium sandbox escapes are Linux kernel bugs
22:30:39 <Railgun_Lover[m]> Didn't Windows use to have bad security? I think that's where much of the misconception comes from, they see "Windows" and think of a shoddy, unstable, buggy mess from 2001
22:30:42 <strcat[m]> and similarly on Windows, they're kernel bugs
22:30:51 <strcat[m]> rarely bugs in the Chromium code outside the sandboxes
22:30:53 <strcat[m]> mostly kernel bugs
22:31:16 <strcat[m]> and Chromium is likely going to adopt memory safe languages for the trusted stuff outside the sandbox and also at a slower rate inside the sandbox too
22:31:26 <strcat[m]>  * and Chromium is going to adopt memory safe languages for the trusted stuff outside the sandbox and also at a slower rate inside the sandbox too
22:31:34 <Railgun_Lover[m]> RIght because they don't want to reduce the security
22:31:36 <strcat[m]> should just say they are, not they are likely going to, since it's essentially announced now
22:32:16 <Railgun_Lover[m]> <Railgun_Lover[m] "RIght because they don't want to"> by using them wrong and then exploits can bypass security features in either language
22:32:26 <strcat[m]> OS sandboxes, permission models, access control, and all that kind of stuff entirely depends on the kernel being secure but the kernel is actually the least secure component on Android so...
22:32:29 <Railgun_Lover[m]> > <@grapheneos_user_pi:matrix.org> RIght because they don't want to reduce the security
22:32:29 <Railgun_Lover[m]>  * by using them wrong and then exploits can bypass security features in the other language
22:32:47 <strcat[m]> that's why so much effort goes into mitigations for it (which don't resolve the root issues, but help reduce the harm) and attack surface reduction
22:33:26 <strcat[m]> Google is developing a framework for writing Linux kernel code in Rust but they are dealing with a culture that's not going to be supportive of it and it's going to be rough going for political reasons
22:33:37 <strcat[m]> and the monolithic kernel thing is still an issue
22:34:05 <strcat[m]> so, with Rust, 95% of the code can just be safe code not trusted to get memory safety right, but you still have low-level building blocks where you can have those bugs
22:34:11 <strcat[m]> bug you can focus your resources on making those secure
22:34:15 <strcat[m]> but still
22:34:27 <strcat[m]> you do not want a bug in one those bits to be game over
22:34:46 <strcat[m]> sandboxing + memory safe languages + exploit mitigations are layers of security
22:34:47 <Railgun_Lover[m]> Why don't people use Rust/other memory safe languages? I can understand if libraries, etc. are only on C or developers don't know them, but Rust even offers the option of memory unsafety
22:34:56 <strcat[m]> Linux kernel has no security layers, really
22:35:03 <strcat[m]> it's just one massive blob of trusted, unsafe code with weak mitigations
22:35:03 <Railgun_Lover[m]> If they're stubborn enough to want that option
22:35:16 <Railgun_Lover[m]> <strcat[m] "it's just one massive blob of tr"> muh performance
22:35:21 <strcat[m]> and it grows in complexity and size at a really fast pace
22:35:28 <strcat[m]> bugs added faster than they're fixed
22:35:57 <strcat[m]> if bugs were not being added faster than they're being fixed, the rate of finding bugs could not keep growing
22:36:28 <Railgun_Lover[m]> how is it that this OS, so insecure, has a cult so dedicated to anti security
22:36:36 <Railgun_Lover[m]> well i guess that goes hand in hand
22:36:36 <strcat[m]> automated fuzzing, etc. finding hundreds or more memory corruption bugs every month is a pretty serious problem
22:36:46 <strcat[m]> and that's just the low-hanging fruit that's easy to find
22:36:54 <strcat[m]> they do not have resources to fix most of the bugs
22:36:59 <strcat[m]> it's unworkable
22:37:26 <strcat[m]> you know how easy it is to find an unfixed memory corruption bug in Linux? go look at the fuzzing results and there you go, tens of thousands of them, unfixed
22:37:36 <Railgun_Lover[m]> TENS OF THOUSANDS?????
22:37:49 <strcat[m]> yeah
22:37:58 <strcat[m]> just try running perf fuzzer on your machine it will crash within ~5 hours
22:38:11 <strcat[m]> not my fault if your data gets corrupted for making that suggestion
22:38:12 <Railgun_Lover[m]> Linux is very stable until you exploit it
22:38:27 <strcat[m]> perf fuzzer on a lot of platforms crashes the OS in seconds
22:38:34 <Railgun_Lover[m]> lol
22:38:38 <Railgun_Lover[m]> VM time
22:38:45 <strcat[m]> and btw the perf maintainers upstream rejected the downstream toggle to disallow it completely for unprivileged users
22:38:48 <strcat[m]> Android uses that
22:38:58 <ypm[m]> since unix, more specifically linux pretty much dominates server market share, how do they cope? i figure theres a larger incentive to develop malware for servers than for desktop linux
22:39:02 <strcat[m]> they want perf to be available everywhere for profiling including JITs etc.
22:39:11 <strcat[m]> so they refused to add a toggle to allow people to disable it
22:39:14 <strcat[m]> Android does it anyway
22:39:15 <Railgun_Lover[m]> <ypm[m] "since unix, more specifically li"> different attack vectors and actual hardening
22:39:39 <strcat[m]> when you enable developer options and ADB, then use a profiler, the profiler enables perf (only adb shell can do it)
22:39:43 <strcat[m]> btw that feature is from GrapheneOS
22:39:48 <strcat[m]> I upstreamed it
22:39:52 <Railgun_Lover[m]> nice!
22:39:59 <strcat[m]> previously you could crash any phone in minutes via perf fuzzer
22:40:00 <strcat[m]> lol
22:40:06 <Railgun_Lover[m]> lmao
22:40:33 <strcat[m]> some of those bugs are exploitable -> you gather them up, choose the best ones, make exploits
22:40:49 <strcat[m]> you have thousands to work with so you're just picking the nice ones that are easiest to exploit
22:40:53 <strcat[m]> there's no shortage of bugs to exploit
22:41:35 <strcat[m]> it's not really that hard to exploit them either just takes a lot of time, they're easier to exploit than userspace ones in general, since userspace has more hardening available (this applies to platforms like Android actually using modern exploit mitigations like CFI, etc.)
22:41:40 <ypm[m]> <strcat[m] "you have thousands to work with "> you have to account for decision fatigue these poor malware devs have to go through though üòÇ
22:41:50 <Railgun_Lover[m]> <ypm[m] "you have to account for decision"> lol
22:42:02 <strcat[m]> ypm: in all likelihood they'll also focus on the ones in core kernel code for portability
22:42:19 <ypm[m]> makes sense
22:42:24 <strcat[m]> ypm: Qualcomm drivers get a lot more attention than others due to being a broadly deployed platform so a lot more is found / fixed and hardened
22:42:36 <strcat[m]> also, Qualcomm actually fixes the bugs
22:42:47 <ypm[m]> props to them
22:42:51 <strcat[m]> most drivers don't have security teams or maintenance teams with proper resources at all
22:42:58 <strcat[m]> most drivers do not get these bugs fixed
22:43:02 <strcat[m]> at any decent pace
22:43:08 <strcat[m]> they get mass reported by fuzzers and mostly just sit there
22:43:11 <strcat[m]> on mailing lists
22:43:21 <Railgun_Lover[m]> <strcat[m] "also, Qualcomm actually fixes th"> but...but...backdoors!
22:43:24 <Railgun_Lover[m]> jk
22:43:32 <strcat[m]> oh look another bug for this under resourced project that has 1 barely active maintainer who had to reverse engineer the driver without docs
22:43:44 <strcat[m]> and that driver is fully trusted, fully privileged code
22:43:48 <strcat[m]> no isolation / boundaries
22:44:03 <strcat[m]> entirely in a language where any tiny mistake often leads to dangerous code execution bugs, etc.
22:44:17 <Railgun_Lover[m]> Linux tech tips: don't use Linux
22:44:33 <strcat[m]> in C, you make a mistake in a calculation or managing the lifetime of an object and now an attacker gets to run whatever code they want on the machine
22:44:44 <strcat[m]> as opposed to a compile error or runtime bounds check error killing the thread
22:44:51 <Railgun_Lover[m]> I never understood why everyone is like "Linux market share"
22:44:53 <strcat[m]> and I mean tiny little common mistakes
22:44:56 <strcat[m]> pervasive everywhere
22:45:02 <Railgun_Lover[m]> you're just hoping they won't write malware
22:45:21 <Railgun_Lover[m]> which is a great security model
22:45:24 <strcat[m]> I hope that helps with clarifying what's wrong with the Linux kernel a lot of other widely used, traditional software
22:45:43 <Railgun_Lover[m]> it was amazing, there was lots of information
22:45:52 <strcat[m]> when a government targets a dissident and exploits their phone this is what lets them do it so consistently
22:45:52 <Railgun_Lover[m]> legitimately helped understanding
22:45:59 <ypm[m]> hey strcat thanks for taking the time of day to answer random questions on here
22:46:16 <strcat[m]> memory corruption is 99% of what those governments, etc. are exploiting
22:46:29 <strcat[m]> and 95% of that is easily preventable by choosing safer tools
22:46:32 <strcat[m]> isn't that sad?
22:46:36 <strcat[m]> we've known the solution for decades
22:46:57 <strcat[m]> it's like everyone driving around in cars without seatbelts, ABS, crush zones, airbags, etc.
22:47:04 <ypm[m]> so.. rust?
22:47:23 <strcat[m]> basically imagine if everyone was still driving around with 50s cars and people just said "just don't make mistakes driving" and 90% of human deaths were from car accidents
22:47:29 <strcat[m]> that is how software works right now with memory corruption
22:47:34 <Railgun_Lover[m]> That was what they did
22:47:39 <Railgun_Lover[m]> seatbelts took so long to implement
22:47:54 <strcat[m]> not really
22:48:10 <Railgun_Lover[m]> true, they actually fixed it
22:48:23 <strcat[m]> software is unregulated and somehow companies aren't liable for the harm caused by their products
22:48:46 <strcat[m]> and also the companies really don't care
22:48:57 <strcat[m]> car companies largely adopt that stuff themselves and people choose cars based on safety too
22:48:59 <ypm[m]> so just use rust then? or you have another language in mind as a better alternative
22:49:01 <Railgun_Lover[m]> Linux DOES have a valid reason for bad security
22:49:10 <strcat[m]> ypm: Rust for low-level / highest performance code
22:49:12 <strcat[m]> ypm: most code does not need Rust
22:49:21 <strcat[m]> Rust is the replacement for C and C++
22:49:32 <strcat[m]> a lot of software written in C and C++ should just be written in a higher level language
22:49:36 <strcat[m]> not Rust
22:49:54 <Railgun_Lover[m]> <Railgun_Lover[m] "Linux DOES have a valid reason f"> though, it is very bad that it's basically the only decent kernel that you can use, though fuchsia is changing that
22:50:09 <strcat[m]> ypm: Android has very broad adoption of memory safety since the beginning
22:50:19 <strcat[m]> ypm: Java and now the much nicer / more modern Kotlin as a replacement
22:50:27 <strcat[m]> ypm: and Android 12 is heavily adopting Rust
22:50:31 <strcat[m]> for the low-level components
22:50:47 <strcat[m]> they've also gradually rewritten a lot of C and C++ stuff in Java/Kotlin where it made no sense for it to be in a low-level language
22:51:21 <ypm[m]> im assuming thats just best practice for security
22:51:28 <strcat[m]> Android's main weakness is the Linux kernel, in nearly every other area it's doing really well with memory safety, mitigations, sandboxing, declarative access control (SELinux), etc.
22:51:53 <strcat[m]> ypm: basically, new software shouldn't be written in C and C++ with some rare exceptions
22:52:13 <strcat[m]> ypm: and existing software in it should gradually migrate away by using Rust or high level languages for newly added components
22:52:23 <strcat[m]> ypm: this is a political problem far more than a technical problem
22:53:07 <strcat[m]> ypm: the problem will resolve itself fairly rapidly if the politics wasn't an issue
22:53:08 <strcat[m]> of course there will still be lots of legacy software in C and C++, etc.
22:53:09 <strcat[m]> but it would be running in a drastically more secure sandbox
22:53:29 <strcat[m]> and over time, it would fade away, and be reduced to smaller and smaller niches
22:53:30 <ypm[m]> wdym by politics? just drama over not wanting to use rust or
22:53:34 <strcat[m]> but right now, it's not fading away
22:53:53 <strcat[m]> ypm: people are invested in using the tools they have traditionally used and are hyper resistant to accepting something is wrong, something is causing harm, etc.
22:53:59 <strcat[m]> they're hostile to change
22:54:05 <strcat[m]> and hostile to accepting there is even a problem
22:54:26 <ypm[m]> ohhh ok, got it
22:54:30 <strcat[m]> and a lot simply don't care partly because a lot of them lack empathy and they just don't care about privacy/security of their users, etc.
22:54:48 <strcat[m]> journalists, etc. are a big part of the problem
22:54:52 <strcat[m]> all this misinformation about privacy and security
22:55:07 <strcat[m]> you aren't actually rewarded much for doing better, you actually have to care, and most do not care, they just want the $$$
22:56:38 <strcat[m]> ypm: exploit mitigations are like seatbelts, ABS, etc. and Rust is like a self-driving car avoiding making errors / getting into accidents where the mistakes
22:57:17 <strcat[m]> ypm: and C programmers are the people strongly opposed to giving up on driving because it's what they've always done and they enjoy it and screw all the people dying from car accidents (one of the biggest causes of deaths)
22:57:17 <strcat[m]> there's a perfect analogy for you
22:57:39 <strcat[m]> also most C programmers are basically drunk driving most of the time by not really caring about these things and using the available tools for safety
22:57:46 <strcat[m]> and they enjoy that too and don't want to bother not doing it
22:58:11 <strcat[m]> https://twitter.com/dril/status/464802196060917762 this is their main argument
22:58:15 <ypm[m]> solution would be to figure out an incentive structure that makes people care then. clearly source available software can be superior to closed source, yet its not always the case
22:58:33 <ypm[m]> <strcat[m] "there's a perfect analogy for yo"> yeah
22:58:42 <Wonderfall[m]> Love the analogy
22:59:10 <ypm[m]> <strcat[m] "https://twitter.com/dril/status/"> lmao
22:59:17 <strcat[m]> hardened_malloc wouldn't cause any compatibility issues if developers actually used ASan, etc. and tested with it
22:59:26 <strcat[m]> hardened_malloc is the seatbelt, ABS, etc.
22:59:30 <strcat[m]> Rust is self-driving car
22:59:46 <strcat[m]> you still want a seatbelt in a world where 95% of crashes are eliminated
22:59:58 <strcat[m]>  * hardened_malloc is the seatbelt, air bags, etc.
23:01:30 <strcat[m]> although it'd be a lot less important
23:02:12 <strcat[m]> people really don't realize the horrible state of software privacy and security
23:02:18 <strcat[m]> and how deep it is
23:02:33 <strcat[m]> projects just brand themselves as private or secure without actually being that way at all and get away with that
23:02:35 <strcat[m]> it's sad.
23:04:34 <Wonderfall[m]> Yeah it is. Plus so much misinformation
23:04:38 <wawi[m]> hey
23:04:43 <wawi[m]> indeed it is
23:07:04 <wawi[m]> i often think that we would need to develop a whole new open source kernel from scratch, that would address by design the root problems of Linux
23:07:35 <Wonderfall[m]> The monolithic design should belong to the past
23:07:44 <wawi[m]> actually that would just be a modern Linux
23:08:13 <wawi[m]> yes, with a different architecture thought for security first
23:08:33 <Wonderfall[m]> + less complexity
23:08:39 <Wonderfall[m]>  * and less complexity
23:09:01 <Railgun_Lover[m]> <strcat[m] "https://twitter.com/dril/status/"> lol
23:10:19 <madaidan[m]1> <wawi[m] "i often think that we would need"> Zircon
23:10:56 <wawi[m]> hi mate, i'll check that out
23:11:03 <Wonderfall[m]> Zircon, SEL4... Although Zircon is not directly branded as a microkernel, it has many concepts from it
23:11:32 <Core6255> nobody has any thoughts on Haskell?
23:11:52 <wawi[m]> ah ok it's included in fuschia
23:12:48 <Railgun_Lover[m]> <madaidan[m]1 "Zircon "> but muh copyleft license
23:13:25 <wawi[m]> nice, i think we badly need more minimalist software
23:22:18 <ypm[m]> <strcat[m] "it's sad."> tysm for all the information you posted. It's been a really informative read :)
23:39:52 <Cliff[m]> Been reading up on fuchsia and zircon, amazing stuff. Is there anything known when it will be available?
23:43:54 <pkgbuild[m]> Is normal to receive SMS only on the property user's?
23:46:21 <pkgbuild[m]> * Is normal to receive SMS only on the proprietary user's?
23:53:03 <strcat[m]> you need to enable full SMS / phone call support for other users from the owner profile user management
23:53:05 <strcat[m]> if that's what you mean
23:53:08 <strcat[m]> not really clear what you mean
23:53:22 <strcat[m]> and it's known third party SMS apps don't generally have working support for user profiles
